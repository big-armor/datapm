import { Difference, DifferenceType, PackageFile, PublishMethod, RegistryReference } from "datapm-lib";
import fs from "fs";
import { Ora } from "ora";
import path from "path";
import { SemVer } from "semver";
import { fetchMultipleWithListr } from "../command/FetchCommandModule";
import { CredentialsBySourceSlug } from "../command/PublishPackageCommandModule";
import { CreateVersionInput } from "../generated/graphql";
import { obtainCredentials } from "./CredentialsUtil";
import { identifierToString } from "./IdentifierUtil";
import { getRegistryClientWithConfig } from "./RegistryClient";
import { exit } from "yargs";
import { DataPMRepositoryDescription } from "../repository/file-based/datapm-registry/DataPMRepositoryDescription";
import numeral from "numeral";

export const DifferenceTypeMessages: Record<DifferenceType, string> = {
    [DifferenceType.REMOVE_SCHEMA]: "Removed Schema",
    [DifferenceType.ADD_SCHEMA]: "Added Schema",
    [DifferenceType.CHANGE_PACKAGE_DISPLAY_NAME]: "Changed Package Display Name",
    [DifferenceType.CHANGE_PACKAGE_DESCRIPTION]: "Changed Package Description",
    [DifferenceType.CHANGE_SOURCE]: "Changed Source",
    [DifferenceType.CHANGE_SOURCE_CONFIGURATION]: "Changed Source Configuration",
    [DifferenceType.CHANGE_STREAM_STATS]: "Changed Stream Stats",
    [DifferenceType.CHANGE_STREAM_UPDATE_HASH]: "Changed Stream Update Hash",
    [DifferenceType.CHANGE_STREAM_STATS]: "Changed Stream Stats",
    [DifferenceType.ADD_PROPERTY]: "Added Property",
    [DifferenceType.REMOVE_PROPERTY]: "Removed Property",
    [DifferenceType.CHANGE_SOURCE_URIS]: "Changed Source URIs",
    [DifferenceType.REMOVE_HIDDEN_PROPERTY]: "Removed Hidden Property",
    [DifferenceType.CHANGE_CONTACT_EMAIL]: "Change Contact Email",
    [DifferenceType.REMOVE_STREAM_SET]: "Remove Stream Set",
    [DifferenceType.REMOVE_SOURCE]: "Removed Source",
    [DifferenceType.REMOVE_HIDDEN_SCHEMA]: "Removed Hidden Schema",
    [DifferenceType.CHANGE_PROPERTY_TYPE]: "Changed Property Type",
    [DifferenceType.CHANGE_PROPERTY_FORMAT]: "Changed Property Format",
    [DifferenceType.CHANGE_PROPERTY_UNIT]: "Changed Property Unit",
    [DifferenceType.CHANGE_PROPERTY_DESCRIPTION]: "Changed Property Description",
    [DifferenceType.CHANGE_GENERATED_BY]: "Changed Generated By",
    [DifferenceType.CHANGE_UPDATED_DATE]: "Changed Updated Date",
    [DifferenceType.CHANGE_VERSION]: "Changed Version",
    [DifferenceType.CHANGE_README_MARKDOWN]: "Changed Readme Markdown",
    [DifferenceType.CHANGE_LICENSE_MARKDOWN]: "Changed License Markdown",
    [DifferenceType.CHANGE_README_FILE]: "Changed Readme File",
    [DifferenceType.CHANGE_LICENSE_FILE]: "Changed License File",
    [DifferenceType.CHANGE_WEBSITE]: "Changed Website",
    [DifferenceType.CHANGE_CONTACT_EMAIL]: "Changed Contact Email",
    [DifferenceType.HIDE_PROPERTY]: "Property Hidden",
    [DifferenceType.UNHIDE_PROPERTY]: "Property Unhidden",
    [DifferenceType.CHANGE_SOURCE_CONNECTION]: "Changed Source Connection Configuration",
    [DifferenceType.CHANGE_SOURCE_CREDENTIALS]: "Changed Source Credentials"
};

export function differenceToString(difference: Difference): string {
    let pointer = difference.pointer.split("/").pop();

    if (difference.type.toString().includes("_PROPERTY")) {
        const parts = difference.pointer.match(/.*\/properties\/(.*)/);
        if (parts) {
            pointer = parts[1];
        }
    }

    let message = `${DifferenceTypeMessages[difference.type]}`;

    if (pointer != null && pointer.length > 0) message += ` ${pointer}`;

    return message;
}

export function writePackageFile(packageFile: PackageFile): string {
    const packageFileName = `${packageFile.packageSlug}.datapm.json`;
    const packageFileLocation = path.join(process.cwd(), packageFileName);
    const json = JSON.stringify(packageFile, null, " ");

    fs.writeFileSync(packageFileLocation, json, "utf8");

    return packageFileLocation;
}

export function writeReadmeFile(packageFile: PackageFile): string {
    const fileLocation = path.join(process.cwd(), `${packageFile.packageSlug}.README.md`);
    const contents = `# ${packageFile.displayName}\n \n ${packageFile.description}`;

    fs.writeFileSync(fileLocation, contents, "utf8");

    return fileLocation;
}

export function writeLicenseFile(packageFile: PackageFile): string {
    const fileLocation = path.join(process.cwd(), `${packageFile.packageSlug}.LICENSE.md`);
    const contents = "# License\n\nLicense not defined. Contact author.";

    fs.writeFileSync(fileLocation, contents, "utf8");

    return fileLocation;
}

export enum PublishSchemaSteps {
    CONNECT = "connect",
    FIND_EXISTING_PACKAGE = "find_existing_package",
    UPDATING_PACKAGE_LISTING = "updating_package_listing",
    UPDATED_PACKAGE_LISTING = "updated_package_listing",
    FOUND_EXISTING_PACKAGE = "found_existing_package",
    NO_EXISTING_PACKAGE_FOUND = "no_existing_package_found",

    CREATE_PACKAGE = "publish_package_file",
    CREATE_PACKAGE_SUCCESS = "publish_package_file_success",
    CREATE_VERSION = "publish_version",
    CREATE_VERSION_SUCCESS = "publish_version_success",
    VERSION_EXISTS_SUCCESS = "version_exists_success"
}

export interface PublishProgress {
    updateStep(step: PublishSchemaSteps, registry: RegistryReference): void;
}

/** Returns boolean of whether the package file was changed during the saving process */
export async function publishPackageFile(
    oraRef: Ora,
    packageFile: PackageFile,
    targetRegistries: RegistryReference[]
): Promise<boolean> {
    const credentialsBySourceSlug: CredentialsBySourceSlug = new Map();

    let packageFileChanged = false;

    for (const source of packageFile.sources) {
        const credentials = await obtainCredentials(oraRef, source);
        credentialsBySourceSlug.set(source.slug, credentials);
    }

    await attemptPublishPackageFile(oraRef, packageFile, targetRegistries, credentialsBySourceSlug)
        .catch(async (error) => {
            if (error.networkError) {
                if (error.networkError.result) {
                    if (error.networkError.result.errors[0].message.indexOf("API_KEY_NOT_FOUND") !== -1) {
                        oraRef.fail("Failed to publish: Your API KEY is out of date.");
                        oraRef.info("Genarate a new API Key in this registry's web console");
                    } else {
                        oraRef.fail(`Failed to publish: ${error.networkError.result.errors[0].message}`);
                    }
                } else oraRef.fail(`Failed to publish: ${error.networkError.bodyText || error.networkError.message}`);

                throw error;
            }

            if (error.message === "README_FILE_NOT_FOUND") {
                oraRef.fail(`Could not find the README file with the relative path of ${packageFile.readmeFile}`);
                throw error;
            }

            if (error.message === "LICENSE_FILE_NOT_FOUND") {
                oraRef.fail(`Could not find the LICENSE file with the relative path of ${packageFile.licenseFile}`);
                throw error;
            }

            if (error.extensions?.code === "HIGHER_VERSION_REQUIRED") {
                oraRef.warn(
                    `Because of the changes in this file, the version number must be at least ${error.extensions?.minNextVersion}`
                );

                packageFile.version = error.extensions?.minNextVersion;
                packageFileChanged = true;

                try {
                    await attemptPublishPackageFile(oraRef, packageFile, targetRegistries, credentialsBySourceSlug);
                } catch (error) {
                    oraRef.fail(`Error publishing version after version change. ${error.messasge}`);
                    throw error;
                }
                oraRef.succeed("Published to registry after version update");
            } else {
                throw error;
            }
        })
        .then(() => {
            oraRef.succeed("Published package file to registry");
        })
        .catch((error) => {
            oraRef.fail(`Failed to publish: ${error.message}`);
            process.exit(1);
        });

    const registryForDataPublishing = targetRegistries.filter(
        (registry) => registry.publishMethod === PublishMethod.SCHEMA_AND_DATA
    );

    if (registryForDataPublishing.length > 0) {
        oraRef.info("Publishing data...");

        for (const targetRegistry of registryForDataPublishing) {
            try {
                const results = await publishData(oraRef, packageFile, targetRegistry);

                const totalRecordCount = Object.values(results).reduce((acc, result) => acc + result, 0);

                oraRef.succeed(
                    `Finished uploading ${numeral(totalRecordCount).format("0,0")} records to ` +
                        targetRegistry.url +
                        "/" +
                        targetRegistry.catalogSlug +
                        "/" +
                        packageFile.packageSlug
                );
            } catch (error) {
                oraRef.fail(`Failed to publish data: ${error.message}`);
                exit(1, error);
            }
        }
    }

    return packageFileChanged;
}

async function publishData(
    oraRef: Ora,
    packageFile: PackageFile,
    targetRegistry: RegistryReference
): Promise<{ [key: string]: number }> {
    const dataPMRepositoryDescription = new DataPMRepositoryDescription();

    const dataPMSinkDescription = await dataPMRepositoryDescription.getSinkDescription();

    if (dataPMSinkDescription == null) {
        throw new Error("DATAPM_SINK_DESCRIPTION_NOT_FOUND");
    }

    const dataPMSink = await dataPMSinkDescription.loadSinkFromModule();

    return await fetchMultipleWithListr(
        oraRef,
        packageFile,
        {
            catalogSlug: targetRegistry.catalogSlug,
            packageSlug: packageFile.packageSlug,
            packageMajorVersion: new SemVer(packageFile.version).major
        },
        dataPMSink,
        {
            url: targetRegistry.url
        },
        {},
        {
            catalogSlug: targetRegistry.catalogSlug,
            packageSlug: packageFile.packageSlug,
            majorVersion: new SemVer(packageFile.version).major
        },
        true,
        false,
        false
    );
}

async function attemptPublishPackageFile(
    oraRef: Ora,
    packageFile: PackageFile,
    targetRegistries: RegistryReference[],
    credentialsBySourceSlug: CredentialsBySourceSlug
): Promise<void> {
    await uploadPackageFile(packageFile, targetRegistries, credentialsBySourceSlug, {
        updateStep: (step: PublishSchemaSteps, registryRef: RegistryReference) => {
            switch (step) {
                case PublishSchemaSteps.FIND_EXISTING_PACKAGE:
                    oraRef.start("Finding existing package...");
                    break;

                case PublishSchemaSteps.FOUND_EXISTING_PACKAGE:
                    oraRef.succeed(
                        "Found the existing package - " +
                            identifierToString({
                                registryURL: registryRef.url,
                                catalogSlug: registryRef.catalogSlug,
                                packageSlug: packageFile.packageSlug
                            })
                    );
                    break;

                case PublishSchemaSteps.UPDATING_PACKAGE_LISTING:
                    oraRef.start("Updating package description and name");
                    break;

                case PublishSchemaSteps.UPDATED_PACKAGE_LISTING:
                    oraRef.succeed("Updated package listing");
                    break;

                case PublishSchemaSteps.NO_EXISTING_PACKAGE_FOUND:
                    oraRef.succeed("Existing package not found.");
                    break;

                case PublishSchemaSteps.CREATE_PACKAGE:
                    oraRef.start(`Creating new package listing ${registryRef.catalogSlug}/${packageFile.packageSlug}`);
                    break;

                case PublishSchemaSteps.CREATE_PACKAGE_SUCCESS:
                    oraRef.succeed(`Created new package listing ${registryRef.catalogSlug}/${packageFile.packageSlug}`);
                    break;

                case PublishSchemaSteps.CREATE_VERSION:
                    oraRef.start(`Publishing version ${packageFile.version}`);
                    break;

                case PublishSchemaSteps.CREATE_VERSION_SUCCESS:
                    oraRef.succeed(`Published version ${packageFile.version}`);
                    break;

                case PublishSchemaSteps.VERSION_EXISTS_SUCCESS:
                    oraRef.succeed(`Updated existing version ${packageFile.version}`);
                    break;
            }
        }
    });
}

export async function uploadPackageFile(
    packageFile: PackageFile,
    targetRegistries: RegistryReference[],
    credentialsBySourceSlug: CredentialsBySourceSlug,
    context: PublishProgress
): Promise<Map<RegistryReference, boolean>> {
    const returnValue: Map<RegistryReference, boolean> = new Map();

    for (const registryRef of targetRegistries) {
        context.updateStep(PublishSchemaSteps.FIND_EXISTING_PACKAGE, registryRef);

        const registry = getRegistryClientWithConfig(registryRef);

        try {
            const existingPackage = await registry.getPackage({
                catalogSlug: registryRef.catalogSlug,
                packageSlug: packageFile.packageSlug
            });

            if (existingPackage.errors) {
                throw existingPackage.errors[0];
            }

            context.updateStep(PublishSchemaSteps.FOUND_EXISTING_PACKAGE, registryRef);

            context.updateStep(PublishSchemaSteps.UPDATING_PACKAGE_LISTING, registryRef);

            await registry.updatePackage(
                {
                    catalogSlug: registryRef.catalogSlug,
                    packageSlug: packageFile.packageSlug
                },
                {
                    description: packageFile.description,
                    displayName: packageFile.displayName
                }
            );

            context.updateStep(PublishSchemaSteps.UPDATED_PACKAGE_LISTING, registryRef);
        } catch (error) {
            if (!error.message.includes("PACKAGE_NOT_FOUND")) {
                throw error;
            }

            context.updateStep(PublishSchemaSteps.NO_EXISTING_PACKAGE_FOUND, registryRef);

            context.updateStep(PublishSchemaSteps.CREATE_PACKAGE, registryRef);

            await registry.createPackage({
                catalogSlug: registryRef.catalogSlug,
                packageSlug: packageFile.packageSlug,
                description: packageFile.description,
                displayName: packageFile.displayName
            });
            context.updateStep(PublishSchemaSteps.CREATE_PACKAGE_SUCCESS, registryRef);
        }

        context.updateStep(PublishSchemaSteps.CREATE_VERSION, registryRef);

        const versions = generateCreateVersion(packageFile, registryRef, credentialsBySourceSlug);

        const serverResponse = await registry.createVersion(versions, {
            catalogSlug: registryRef.catalogSlug,
            packageSlug: packageFile.packageSlug
        });

        if (serverResponse.errors) {
            if (serverResponse.errors.find((error) => error.extensions?.code === "VERSION_EXISTS") !== undefined)
                context.updateStep(PublishSchemaSteps.VERSION_EXISTS_SUCCESS, registryRef);
            else throw serverResponse.errors[0];
        } else {
            context.updateStep(PublishSchemaSteps.CREATE_VERSION_SUCCESS, registryRef); // FIXME ONLY SHOW THIS IF THE VERSION HAS ACCTUALLY CHANGED
        }

        returnValue.set(registryRef, true);
    }

    return returnValue;
}

function generateCreateVersion(
    packageFileObject: PackageFile,
    registryReference: RegistryReference,
    _credentialsBySourceSlug: CredentialsBySourceSlug // This will be used for proxy feature
): CreateVersionInput {
    // deep copy the package file
    const packageFile = JSON.parse(JSON.stringify(packageFileObject)) as PackageFile;

    // filter out all othe registries
    packageFile.registries = [registryReference];

    if (registryReference.publishMethod === PublishMethod.SCHEMA_PROXY_DATA) {
        throw new Error("Publishing with credentials not yet implemented");
    }

    const version: CreateVersionInput = {
        packageFile: JSON.stringify(packageFileObject)
    };

    return version;
}
